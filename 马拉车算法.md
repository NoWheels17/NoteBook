## 马拉车算法特点

马拉车算法是专门针对回文文本处理的算法，主要优秀在把时间复杂度降到了O(n)

## 什么是回文

回文字符串分为奇回文和偶回文。m = `12321`就是奇回文，回文的中心是`3`，长度为奇数；n = `1221`则是偶回文，回文的中心是两个`2`之间，长度为偶数。

从中心开始，到回文的左/右边界的长度称为臂长，那么m的臂长L就就为2，n的臂长也为，对于奇回文长度S=2L+1，对于偶回文长度S=2L。

## 例题

寻找`babcbabcbaccba`中所有回文字符串

## 常规解法（中心扩散）

中心扩散解法是最常规的解法，其思路是设计两层循环，外层循环用来遍历每一个字符，并将其假设为回文的中心，内层循环为设置双指针，从中心点开始向两侧移动，如果字符不相等或者遇到边界，则内循环结束，开始下一个中心的回文字符串查找，直到外层循环遍历完，这样就能获得所有奇回文字符串。

同样的思路，以字符串之间的位置为中心再遍历一次，能找到所有的偶回文字符串，下面写出奇回文代码：

``` java
String str = "babcbabcbaccba";
int strLen = str.length();
// 寻找奇回文
int left, right, L;
for (int i = 0; i < strLen; i++) {
    L = 0; // 重置臂长计数
    for (left = i - 1, right = i + 1 ;
         left >= 0 && right < strLen && str.charAt(left) == str.charAt(right);) {
        L++;
        left--;
        right++;
    }
    if (L > 0) {
        System.out.println("查找到奇回文字符串：" + str.substring(left + 1, right));
    }
}
// 寻找偶回文
for (int i = 0; i < strLen - 1; i++) {
    L = 0; // 重置臂长计数
    for (left = i, right = i + 1 ;
         left >= 0 && right < strLen && str.charAt(left) == str.charAt(right);) {
        L++;
        left--;
        right++;
    }
    if (L > 0) {
        System.out.println("查找到偶回文字符串：" + str.substring(left + 1, right));
    }
}
```

上面的代码可以写的更加简单一些，只是为了展示思路，所以没有太省略。从上面的代码可以看出，时间复杂度为O(n^2)。那马拉车算法是怎么把时间复杂度拉到O(n)的呢？

## 马拉车思路

在学习马拉车算法的时候，自己是先接受了其所有的概念，然后整合到一起再理解所有的实现思路，这里在整理的时候我选择将马拉车的算法特点单独拉出来分析。

### 统一奇偶问题

从上面暴力解法我们可以看出来，回文的寻找需要区分奇偶两种情况，马拉车算法的第一步则是将原有的字符串拓展，保证每个字符左右都有一个填充字符（字符需要是原字符中没有的），例如：

``` txt 
1221 -> #1#2#2#1#

12321 ->  #1#2#3#2#1#
```

这样处理之后，字符串的长度为2*n+1，而且里面不存在偶回文的子字符串，且有如下规律：

- 当在拓展后的字符串中找到臂长`L>1`的回文子串时，说明有回文子串存在，令原字符串中的索引为`start`和`end`，拓展后的字符串索引为`left`和`right`，则有

  ```text
  start = left / 2
  end = right / 2 - 1
  ```

- 令原字符串的为`index`，拓展后的字符串索引为`pos`，则有

  ```text
  pos % 2 == 0时，对应不上原字符串索引
  pos % 2 == 1时，index = pos / 2
  ```

实际在写代码的时候，其实不需要真正的去拓展字符串，只要保证索引拓展正确即可，代码如下：

``` java
int strLen = str.length() * 2 + 1; // 单独拓展索引
int left, right, L;
for (int i = 0; i < strLen; i++) {
    L = 0;
    // 循环用来初始化左右指针、判断边界、挪动指针
    for (left = i - 1, right = i + 1; left >= 0 && right < strLen; left-- , right++) {
        // 内层用来处理字符串是否匹配的逻辑

        // left % 2 == 0, 因为编译不优化 %2 所以手动优化，当index为偶数时，说明当前位置为“填充字符”，那么直接继续
        if ((left & 1) == 1 && str.charAt(left >> 1) != str.charAt(right >> 1)) {
            break;
        }
        L++;
    }
    if (L > 1) {
        // 因为最后的位置要么是刚好越界了，要么是走到了回文的外缘，这里需要先矫正回来，再转换到真实坐标
        left = (left+1) >> 1;
        right = ((right-1) >> 1) - 1;
        System.out.println("中心:" + (i / 2) + "回文:" + str.substring(left, right+1)); // substring函数右边界需要+1
    }
}
```

### 巧用回文特性

仔细观察`bzbybabybzc`可以发现，这个字符串里最长的回文字符串是`zbybabybz`（去除了头尾的1个字符），从这里可以发现，这个回文的中心是`a`,但同时也发现`a`的左右两侧都有回文`byb`，在中心扩散法解题的时候，这个2个回文字符串都是需要以`y`为中心重复判定的，但是马拉车算法利用了回文的对称性，在找到左边的`byb`时会保存回文中心索引和回文臂长，这样根据对称特性，等以`a`为中心找完回文后，右边的`byb`就不需要判断了。

## 解法步骤

回到上面的题目，我们先扩展字符串，并给出示意图（示意图1）：

``` text
拓展字符：# b # a # b # c # b # a # b # c # b # a # c # c # b # a #
回文臂长：0 1 0 3 0 1 0 7 0 1 0 ？
回文起止：> - - - - - - - - - - - - - <
标记字母：l - - i - - - m - - - j - - r
索引编号：0 1 2 3 4 5 6 7 8 9 A B C D E
（为方便展示，索引用16进制表示）
```

#### 端点维护

维护最右回文端点索引`r`和这个回文的中心点索引`m`，以及每个点回文臂长`Sn`。以上面`示意图1`为参考，下面解释怎么维护。

- 当遍历到`index=1`的字母`b`时有：

  ```text
  r = 2 、 m = 1 、回文臂长S1 = r - m = 1
  ```

- 遍历到`index=2`的`#`时有：

  ``` text
  r = 2 、m = 2 、回文臂长S2 = r - m = 0
  ```

  因为最右臂长有更新，所以中心点也要更新

- 遍历到`index=3`的`a`时有：

  ``` text
  r = 6 、 m = 3 、回文臂长S3 = r - m = 3
  ```

  因为最右端点更新了，所以`m`也要变化

#### 对称求解

如`示意图1`，当我们遍历到`j=11`的点时，当前的`r=15 m=7`那以位置`j`为中心的回文字符最右端点`jr`怎么求呢?

- `j < r`时，也就是图中的情况，此时可先令回文臂长`Sj=min(r-j, S(2m-j))`，这里解释一下为什么要取二者的最小值，而不是直接`Sj=S(2m-j)`看这个例子：

  ```text
  拓展字符：# c # a # b # a # c # a # b # a #
  回文臂长：0 1 0 1 0 5 0 1 0 7 0 1 0 ？
  回文起止：    > - - - - - - ↑ - - - - - - <
  标记字母：    l - - i - - - m - - - j - - r
  索引编号：0 1 2 3 4 5 6 7 8 9 A B C D E F
  
  这个例子里，i-5,m=9,j=13,r=16
  S(2m-j)=S(i)=S(5)=5，从图里可以看出，实际Sj=r-j=16-13=3的，Sj≠S(2m-j)
  ```

  所以我们是先令`Sj=min(r-j, S(2m-j))`，然后再开始左右扩散求实际的臂长，即：

  ```java
  while (str[j+S[j]] == str[j-S[j]]) {
    S[j]++;
  }
  S[j]--; // 对称点的最右侧在这里会重新计数
  // 循环结束之后如果发现S[i]>=r,那么就更新r、m的值
  ```

- `j>=r`时，直接先令`Sj=1`，然后再左右开始扩散，如上代码

#### 时间复杂度

因为算法一直是在更新最右臂长，且复用了对称点的臂长，所以时间复杂度为O(n)，因为字符串可以虚拟拓展，但是实际每个索引的臂长都要维护，所以空间复杂度为O(2n)。Demo代码如下：

```java
String originStr = "babcbabcbaccba";
int newStrLen = originStr.length() * 2 + 1;
int S[] = new int[newStrLen];
int r = 0, m = 0;
for (int i = 0; i < newStrLen; i++) {
    if (i < r) {
        S[i] = Math.min(r - i, S[2 * m - i]);
        // 下面这个判断是为了剪枝
        if (S[i] <= 0) {
            continue;
        } else {
            S[i]++;
        }
    } else {
        S[i] = 1;
    }
    for (int il = i - S[i], ir = i + S[i]; il >= 0 && ir < newStrLen;) {
      	// 这里(il&1) == 0表示偶数，这个位置的索引是#填充符
        if ((il&1) == 0 || originStr.charAt(il - 1 >> 1) == originStr.charAt(ir - 1 >> 1)) {
            S[i]++;
            il--;
            ir++;
        } else {
            break;
        }
    }
    if (--S[i] + i >= r) {
        r = S[i] + i;
        m = i;
    }
    if (S[i] > 1) {
        int subL = i - S[i] + 1 >> 1;
        int subR = i + S[i] - 1 >> 1;
         System.out.println(i + " 臂长：" + S[i] + " -> " + originStr.substring(subL, subR + 1));
    }
}
```

